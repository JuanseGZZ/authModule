project: auth-mvp
version: 1.1
goal: "Módulo de autenticación con JWT (access) + refresh tokens con rotación y firma JWS, listo para implementación."

target_stack:
  framework: "FastAPI (Python 3.11+)"
  crypto:
    jws_alg: "HS256"          # MVP; diseñar interfaz para migrar a RS256 sin romper contratos
    pwd_hash: "bcrypt"
    refresh_hash: "sha256"    # solo hash en DB (nunca almacenar el raw)
  jwt:
    iss: "auth-mvp"
    aud: "auth-mvp-clients"
    alg: "HS256"
    clock_skew_sec: 60
    required_claims: [sub, iss, aud, iat, exp, jti]
    optional_claims: [nbf, scope]
  timezone: "UTC"

env:
  AUTH_JWT_SECRET: "<32+ bytes>"          # clave simétrica para HS256
  AUTH_ACCESS_TTL_MIN: 15
  AUTH_REFRESH_TTL_DAYS: 14
  AUTH_COOKIE_DOMAIN: null                # ej: ".example.com" si se usan cookies
  AUTH_COOKIE_SECURE: true
  AUTH_COOKIE_SAME_SITE: "Lax"            # Lax/Strict/None
  AUTH_RATE_LIMIT_LOGIN_PER_15M: 10       # por IP
  AUTH_RATE_LIMIT_REFRESH_PER_15M: 30     # por IP
  AUTH_ISS: "auth-mvp"
  AUTH_AUD: "auth-mvp-clients"

conventions:
  error_shape: { error: { code: string, message: string } }
  error_codes:
    - AUTH_INVALID_CREDENTIALS
    - AUTH_EMAIL_NOT_VERIFIED
    - AUTH_TOKEN_EXPIRED
    - AUTH_TOKEN_REVOKED
    - AUTH_REFRESH_NOT_FOUND
    - AUTH_RATE_LIMIT
    - AUTH_BAD_REQUEST
    - AUTH_FORBIDDEN
  tokens:
    access: "JWT JWS firmado (Bearer)"
    refresh: "opaco (random 256 bits) entregado como string o cookie httpOnly"
  cookies:
    refresh_cookie_name: "refresh_token"
    use_http_only: true
    path: "/auth"
  headers:
    access_header: "Authorization: Bearer <jwt>"
    idempotency: "Idempotency-Key (opcional en /auth/login para evitar dobles clicks)"

data_model:
  users:
    id: "uuid, pk"
    email: "citext, unique, indexed"
    password_hash: "text (bcrypt)"
    email_verified: "boolean, default false"
    created_at: "timestamptz, default now()"
    updated_at: "timestamptz, default now()"
  refresh_tokens:
    id: "uuid, pk"
    user_id: "uuid fk -> users(id) on delete cascade"
    token_hash: "bytea (sha256 del refresh raw), unique"
    issued_at: "timestamptz, default now()"
    expires_at: "timestamptz > issued_at"
    revoked_at: "timestamptz, nullable"
    parent_id: "uuid fk -> refresh_tokens(id), nullable (rotación)"
    user_agent: "text, nullable"
    ip: "inet, nullable"
  audit_log_optional:
    id: "bigserial, pk"
    event: "text (auth.login.success|failure, token.refresh.success|reuse_detected, auth.logout)"
    user_id: "uuid fk -> users(id), nullable"
    jti: "text, nullable"
    refresh_id: "uuid fk -> refresh_tokens(id), nullable"
    ip: "inet, nullable"
    user_agent: "text, nullable"
    created_at: "timestamptz, default now()"

indexes:
  - "users(email)"
  - "refresh_tokens(user_id, expires_at)"
  - "refresh_tokens(token_hash)"
  - "audit_log_optional(created_at)"

security_rules:
  password_policy:
    min_len: 8
    require: { letters: true, digits: true }
    forbid_common: true
  jwt_claims:
    sub: "user_id (uuid string)"
    iss: "${AUTH_ISS}"
    aud: "${AUTH_AUD}"
    iat: "epoch seconds"
    exp: "epoch seconds (iat + ACCESS_TTL)"
    jti: "uuid v4"
    scope: "opcional; espacio-separado (p.ej. 'user:read user:write')"
  access_verification:
    steps:
      - "parse + verify signature (HS256 con AUTH_JWT_SECRET)"
      - "check iss/aud/exp/nbf/iat con clock_skew_sec"
      - "no consulta a DB (stateless), salvo listas de revocación si se habilitan"
  refresh_rotation:
    model: "Rotación obligatoria: cada uso invalida el token anterior (revoked_at) y crea uno nuevo con parent_id = anterior."
    reuse_detection: "Si llega un refresh ya revocado, marcar cadena ascendiente como comprometida y revocar descendencia."
  storage:
    never_store_raw_refresh: true
    store_only_hash: true

api:
  - method: POST
    path: /auth/register
    auth: public
    request: { email: string, password: string }
    responses:
      "201": { id: uuid, email: string, email_verified: boolean }
      "400": { error: { code: AUTH_BAD_REQUEST, message: string } }
    effects:
      - "Crear usuario con email normalizado; password_hash=bcrypt."
      - "email_verified=false (MVP sin verificación real)."

  - method: POST
    path: /auth/login
    auth: public
    request: { email: string, password: string }
    responses:
      "200": { access_token: jwt, refresh_token?: opaque, token_type: "Bearer", expires_in: 900 }
      "401": { error: { code: AUTH_INVALID_CREDENTIALS, message: string } }
      "429": { error: { code: AUTH_RATE_LIMIT, message: string } }
    notes:
      - "Si se configuran cookies, setear refresh en cookie httpOnly; sino devolver en body."
    effects:
      - "Validar credenciales sin filtrar existencia del email."
      - "Emitir access (15m) con claims requeridas."
      - "Emitir refresh opaco (14d); persistir sha256 como token_hash."
      - "Crear audit_log_optional.auth.login.success/failure."

  - method: POST
    path: /auth/token/refresh
    auth: public
    request: { refresh_token?: string }  # si no viene en cookie httpOnly
    responses:
      "200": { access_token: jwt, refresh_token?: opaque, token_type: "Bearer", expires_in: 900 }
      "401":
        - { error: { code: AUTH_REFRESH_NOT_FOUND, message: string } }
        - { error: { code: AUTH_TOKEN_REVOKED, message: string } }
        - { error: { code: AUTH_TOKEN_EXPIRED, message: string } }
      "429": { error: { code: AUTH_RATE_LIMIT, message: string } }
    effects:
      - "Buscar refresh por hash; validar no expirado/no revocado."
      - "Rotación: revocar el refresh usado; crear uno nuevo (parent_id = anterior)."
      - "Emitir nuevo access; actualizar cookie si corresponde."
      - "Audit log token.refresh.success o reuse_detected."

  - method: POST
    path: /auth/logout
    auth: "requires refresh (via cookie o body)"
    request: {}
    responses:
      "204": {}
      "401": { error: { code: AUTH_REFRESH_NOT_FOUND, message: string } }
    effects:
      - "Revocar refresh vigente (revoked_at=now()); invalida cadena descendiente."

  - method: GET
    path: /auth/me
    auth: bearer
    request: {}
    responses:
      "200": { id: uuid, email: string, email_verified: boolean }
      "401": { error: { code: AUTH_TOKEN_EXPIRED, message: string } }
    effects:
      - "Decodificar/validar JWT; no tocar DB salvo lectura de usuario."

middleware:
  rate_limit:
    login: { window: "15m", max: ${AUTH_RATE_LIMIT_LOGIN_PER_15M}, key: "IP" }
    refresh: { window: "15m", max: ${AUTH_RATE_LIMIT_REFRESH_PER_15M}, key: "IP" }
  cors:
    allow_origins: ["*"]            # ajustar en prod
    allow_headers: ["Authorization", "Content-Type", "Idempotency-Key"]
    allow_methods: ["POST", "GET", "OPTIONS"]
    allow_credentials: true
  security_headers:
    - "X-Content-Type-Options: nosniff"
    - "X-Frame-Options: DENY"
    - "Referrer-Policy: no-referrer"
    - "Content-Security-Policy: default-src 'none'; frame-ancestors 'none'"

impl_contracts:
  services:
    AuthService:
      methods:
        - name: register
          in: { email: string, password: string }
          out: { id: uuid, email: string, email_verified: boolean }
        - name: login
          in: { email: string, password: string, user_agent?: string, ip?: string }
          out: { access_token: string, refresh_token?: string, expires_in: int }
        - name: refresh
          in: { refresh_token?: string, user_agent?: string, ip?: string }
          out: { access_token: string, refresh_token?: string, expires_in: int }
        - name: logout
          in: { refresh_token?: string }
          out: { ok: true }
        - name: me
          in: { access_token: string }
          out: { id: uuid, email: string, email_verified: boolean }
  token:
    make_access(in: { user_id: uuid, scope?: string }): string
    make_refresh(): { raw: string, hash: bytes, expires_at: timestamptz }
    hash_refresh(in: string): bytes
    verify_access(in: string): { valid: bool, claims?: object, reason?: string }

db_migrations_sql_hint:
  - |
    CREATE EXTENSION IF NOT EXISTS citext;
    CREATE TABLE users (
      id uuid PRIMARY KEY,
      email citext UNIQUE NOT NULL,
      password_hash text NOT NULL,
      email_verified boolean NOT NULL DEFAULT false,
      created_at timestamptz NOT NULL DEFAULT now(),
      updated_at timestamptz NOT NULL DEFAULT now()
    );
  - |
    CREATE TABLE refresh_tokens (
      id uuid PRIMARY KEY,
      user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      token_hash bytea NOT NULL UNIQUE,
      issued_at timestamptz NOT NULL DEFAULT now(),
      expires_at timestamptz NOT NULL,
      revoked_at timestamptz,
      parent_id uuid REFERENCES refresh_tokens(id),
      user_agent text,
      ip inet
    );
    CREATE INDEX ON refresh_tokens(user_id, expires_at);

acceptance_tests:
  - name: "Login OK"
    given: "usuario existente con password válido"
    when: "POST /auth/login"
    then: '200 con {access, refresh}; audit login.success'

  - name: "Login inválido"
    given: "password incorrecto"
    when: "POST /auth/login"
    then: '401 AUTH_INVALID_CREDENTIALS; audit login.failure'

  - name: "Access expirado"
    given: "access expira tras 15m"
    when: "GET /auth/me con access expirado"
    then: "401 AUTH_TOKEN_EXPIRED"

  - name: "Refresh OK (rotación)"
    given: "refresh válido y no revocado"
    when: "POST /auth/token/refresh"
    then: "200 con nuevo access y nuevo refresh; el viejo queda revocado"

  - name: "Refresh reusado"
    given: "refresh ya rotado/revocado"
    when: "POST /auth/token/refresh"
    then: "401 AUTH_TOKEN_REVOKED; audit reuse_detected"

  - name: "Logout"
    given: "usuario con refresh vigente"
    when: "POST /auth/logout"
    then: "204; refresh revocado; futuros refresh ⇒ 401"

  - name: "Rate limit"
    given: ">N intentos rápidos de login o refresh en 15m por IP"
    when: "invocar nuevamente"
    then: "429 AUTH_RATE_LIMIT"

non_functional:
  observability:
    logs: "estructura JSON; incluir request_id, user_id, ip, user_agent, jti"
    metrics: "contadores de login/refresh/logout, errores por código, latencia"
  testability:
    seeds: "crear usuario demo y password determinístico solo en entorno dev"
  migration_path_rs256:
    notes:
      - "Abstraer firma/verificación detrás de interfaz TokenSigner."
      - "Soportar 'kid' en header JWS para rotación de claves."
      - "Añadir JWKS endpoint en futura versión si se migra a RS/ES."

security_notes:
  - "Nunca loggear tokens ni password."
  - "Refresh solo en cookie httpOnly + SameSite=Lax si hay frontend web; para apps móviles devolver por body."
  - "Considerar lista de revocación de access (JTI) solo si es requisito; por defecto stateless."
  - "En reuse_detected, revocar cadena y alertar."
  - "Validar 'aud' desde clientes conocidos (configurable)."
