project: auth-mvp-frontend
version: 1.0
purpose: "Frontend web (HTML/CSS/JS) para consumir el Auth-MVP (JWT access + refresh con rotación)."
style: "SPA simple sin framework (vanilla JS + módulos ES)."
tokens:
  transport:
    access: "memoria (JS)"
    refresh: "configurable: 'cookie' (httpOnly en back) o 'body' (enviar en JSON)."
  behavior:
    access_ttl_min: 15
    refresh_ttl_days: 14

backend_contract:
  base_url: "${API_BASE}"  # variable global de config
  endpoints:
    register:
      method: POST
      path: /auth/register
      req: { email: string, password: string }
      res201: { id: uuid, email: string }
      errors: [CONFLICT_EMAIL_TAKEN, VALIDATION_ERROR]
    login:
      method: POST
      path: /auth/login
      req: { email: string, password: string }
      res200: { access_token: jwt, refresh_token: opaque?, token_type: "Bearer", expires_in: 900 }
      errors: [AUTH_INVALID_CREDENTIALS, AUTH_RATE_LIMIT]
    refresh:
      method: POST
      path: /auth/token/refresh
      req_cookie_or_body: "{refresh_token?: string}"
      res200: { access_token: jwt, refresh_token?: opaque, expires_in: 900 }
      errors: [AUTH_REFRESH_NOT_FOUND, AUTH_TOKEN_REVOKED, AUTH_TOKEN_EXPIRED, AUTH_RATE_LIMIT]
    logout:
      method: POST
      path: /auth/logout
      req_cookie_or_body: "{refresh_token?: string}"
      res204: {}
    me:
      method: GET
      path: /auth/me
      headers: { Authorization: "Bearer <access>" }
      res200: { id: uuid, email: string, roles: [string] }
      errors: [AUTH_TOKEN_EXPIRED]

config:
  API_BASE: "definible por env o ventana global"
  REFRESH_TRANSPORT: "cookie | body" # debe coincidir con back
  SESSION_REFRESH_CHECK_INTERVAL_MS: 30000
  ACCESS_EXP_SOON_THRESHOLD_SEC: 60
  RATE_LIMIT_DEBOUNCE_MS: 600

file_structure:
  - index.html
  - styles.css
  - js/app.js
  - js/modules/navigation.js
  - js/modules/auth/register.js
  - js/modules/auth/login.js
  - js/modules/auth/me.js
  - js/modules/auth/session.js
  - js/pages/register/api.js
  - js/pages/register/service.js
  - js/pages/register/utils.js
  - js/pages/register/render.js
  - js/pages/login/api.js
  - js/pages/login/service.js
  - js/pages/login/utils.js
  - js/pages/login/render.js
  - js/pages/me/api.js
  - js/pages/me/service.js
  - js/pages/me/utils.js
  - js/pages/me/render.js
  - js/pages/session/api.js
  - js/pages/session/service.js
  - js/pages/session/render.js
  - js/shared/models/models.js
  - js/shared/service/tokenStore.js
  - js/shared/service/authState.js
  - js/shared/utils/httpBase.js
  - js/shared/utils/withAuthFetch.js
  - js/shared/utils/authHeaderBuilder.js
  - js/shared/utils/formValidators.js
  - js/shared/utils/toErrorModel.js
  - js/shared/render/showView.js
  - js/shared/render/uiAuthState.js
  - js/shared/render/uiFeedback.js

dom_contracts:
  views:
    - id: viewLogin
    - id: viewRegister
    - id: viewMe
    - id: viewSessionExpired
  nav_buttons:
    - id: navLogin
    - id: navRegister
    - id: navMe
    - id: btnLogout
  login_form:
    - id: formLogin
    - id: loginEmail
    - id: loginPassword
    - id: btnLogin
    - id: showPassLogin
    - id: loginMsg
  register_form:
    - id: formRegister
    - id: registerEmail
    - id: registerPassword
    - id: btnRegister
    - id: registerMsg
  me_view:
    - id: meContent
    - id: meMsg
  expired_view:
    - id: gotoLoginFromExpired

events_and_listeners:
  navigation:
    - element: "#navLogin"      # click -> mostrar viewLogin
      action: showView(viewLogin)
    - element: "#navRegister"   # click -> mostrar viewRegister
      action: showView(viewRegister)
    - element: "#navMe"         # click -> mostrar viewMe y disparar fetchMe()
      action: showView(viewMe) + fetchMe()
  register:
    - element: "#formRegister"
      type: submit
      flow: "submitRegistration(formData) -> register.service.register -> httpBase(POST /auth/register)"
  login:
    - element: "#showPassLogin"
      type: change
      flow: "toggle password input type"
    - element: "#formLogin"
      type: submit
      flow: "submitLogin(formData) -> login.service.login -> httpBase(POST /auth/login) -> tokenStore.setAccess"
  me:
    - element: "#navMe"
      type: click
      flow: "fetchMe() -> withAuthFetch(GET /auth/me) -> renderProfile"
  session:
    - element: "interval@SESSION_REFRESH_CHECK_INTERVAL_MS"
      type: timer
      condition: "authStateIsAuthenticated && tokenStore.isExpiringSoon(ACCESS_EXP_SOON_THRESHOLD_SEC)"
      flow: "refreshTokens() -> session.service.refresh -> httpBase(POST /auth/token/refresh)"
    - element: "#btnLogout"
      type: click
      flow: "logout() -> session.service.logout -> httpBase(POST /auth/logout) -> tokenStore.clear"
    - element: "document"
      event: "session:expired"
      flow: "renderSessionExpired()"

models:
  TokenModel:
    fields: [accessToken, accessExpEpochSec, refreshTransport]
  UserModel:
    fields: [id, email, roles]
  ErrorModel:
    fields: [code, message, httpStatus]
  SessionState:
    fields: [isAuthenticated, lastRefreshAt?]

state_management:
  tokenStore:
    setAccess(input): "guarda access y su exp (epoch)"
    getAccess(): "retorna string | null"
    clear(): "borra access y exp"
    isExpiringSoon(thresholdSec): "bool"
  authState:
    isAuthenticated(): "true si tokenStore.getAccess() != null"
    events: ["authenticated", "session:expired"]  # CustomEvent global

utils:
  httpBase:
    input: { method, url, headers, body }
    behavior:
      - "fetch con credentials:'include' para permitir cookie httpOnly"
      - "parse JSON; si !ok => throw toErrorModel(json,status)"
  withAuthFetch:
    behavior:
      - "inyecta Authorization: Bearer <access>"
      - "si 401 → intentar session.service.refresh() → reintentar una vez → si falla: dispatch('session:expired') y throw"
  authHeaderBuilder:
    behavior: "construye {Authorization: 'Bearer ...'} si hay access"
  formValidators:
    validateEmail: "throw VALIDATION_ERROR si inválido"
    validatePasswordMin: "throw VALIDATION_ERROR si corta"
  toErrorModel:
    behavior: "normaliza {error:{code,message}} + httpStatus a ErrorModel"

services:
  register.service:
    register(email,password):
      calls: "httpBase(POST /auth/register)"
      returns: "UserModel parcial {id,email}"
      errors: [CONFLICT_EMAIL_TAKEN, VALIDATION_ERROR]
  login.service:
    login(email,password):
      calls: "httpBase(POST /auth/login)"
      side_effects:
        - "tokenStore.setAccess(access_token, expires_in)"
        - "si REFRESH_TRANSPORT=body → persistir refresh de forma elegida (definir storage)"
      events: ["authenticated"]
      returns: "TokenModel"
      errors: [AUTH_INVALID_CREDENTIALS, AUTH_RATE_LIMIT]
  me.service:
    getProfile():
      calls: "withAuthFetch(GET /auth/me)"
      returns: "UserModel"
      errors: [AUTH_TOKEN_EXPIRED -> gestionado por withAuthFetch]
  session.service:
    refresh():
      request_mode:
        cookie: "httpBase(POST /auth/token/refresh) sin body"
        body:   "httpBase(POST /auth/token/refresh) con {refresh_token} desde storage"
      side_effects:
        - "tokenStore.setAccess(nuevo_access, expires_in)"
        - "si body: persistir nuevo refresh y descartar el anterior"
      errors: [AUTH_TOKEN_REVOKED, AUTH_TOKEN_EXPIRED, AUTH_REFRESH_NOT_FOUND, AUTH_RATE_LIMIT]
    logout():
      request_mode:
        cookie: "httpBase(POST /auth/logout) sin body"
        body:   "httpBase(POST /auth/logout) con {refresh_token} desde storage"
      side_effects:
        - "tokenStore.clear()"
        - "dispatch('session:expired')"

render_contracts:
  uiAuthState:
    toAuthenticated: "oculta navLogin/navRegister y muestra navMe/btnLogout"
    toUnauthenticated: "inverso del anterior"
    syncNav: "revisa authState y ajusta visibilidad"
  showView:
    input: "viewId"
    behavior: "oculta todas las .view y muestra la indicada"
  uiFeedback:
    toastOk(msg)
    toastInfo(msg)
    toastError(msg)
  register.render:
    success(result): "mensaje OK y sugerir navegar a login"
    error(errorModel): "mapear CONFLICT_EMAIL_TAKEN / VALIDATION_ERROR"
  login.render:
    success(): "uiAuthState.toAuthenticated(); navegar a viewMe"
    error(errorModel): "mapear AUTH_INVALID_CREDENTIALS / AUTH_RATE_LIMIT"
  me.render:
    profile(userModel): "pintar id/email/roles"
    error(errorModel): "si expired → mostrar viewSessionExpired"
  session.render:
    expired(): "uiAuthState.toUnauthenticated(); viewSessionExpired; toast"
    logoutSuccess(): "viewLogin; toast OK"

error_messages_map:
  AUTH_INVALID_CREDENTIALS: "Email o contraseña inválidos."
  AUTH_RATE_LIMIT: "Demasiados intentos. Probá más tarde."
  AUTH_TOKEN_EXPIRED: "Tu sesión expiró."
  AUTH_TOKEN_REVOKED: "Se detectó un problema con la sesión. Volvé a ingresar."
  AUTH_REFRESH_NOT_FOUND: "No se encontró la sesión para renovar."
  CONFLICT_EMAIL_TAKEN: "Ese email ya está registrado."
  VALIDATION_ERROR: "Datos de formulario inválidos."
  UNKNOWN: "Error desconocido."

acceptance_tests_frontend:
  - name: "Register OK"
    steps:
      - "abrir viewRegister"
      - "completar email/password válidos"
      - "submit → espera 201 de /auth/register"
      - "render success + CTA a login"
  - name: "Register duplicado"
    steps:
      - "submit email existente"
      - "mostrar error CONFLICT_EMAIL_TAKEN"
  - name: "Login OK"
    steps:
      - "abrir viewLogin"
      - "completar credenciales válidas"
      - "submit → espera 200 /auth/login"
      - "guardar access en tokenStore"
      - "uiAuthState.toAuthenticated()"
      - "navegar a viewMe"
  - name: "Login inválido"
    steps:
      - "submit credenciales inválidas"
      - "mostrar error AUTH_INVALID_CREDENTIALS"
  - name: "/auth/me con access válido"
    steps:
      - "click navMe"
      - "GET /auth/me con Authorization"
      - "render profile con id/email/roles"
  - name: "/auth/me con access expirado"
    steps:
      - "forzar exp"
      - "GET /auth/me → 401"
      - "withAuthFetch llama a refresh → si OK reintenta y pinta perfil"
  - name: "Refresh OK (rotación)"
    steps:
      - "mantener sesión"
      - "al acercarse el vencimiento → session.service.refresh"
      - "guardar nuevo access (y refresh si body)"
  - name: "Refresh reusado"
    steps:
      - "simular reuso de refresh viejo (solo modo body)"
      - "mostrar sesión expirada → viewSessionExpired"
  - name: "Logout"
    steps:
      - "click btnLogout"
      - "POST /auth/logout → 204"
      - "tokenStore.clear + session:expired"
      - "viewLogin"
  - name: "Rate limit"
    steps:
      - "disparar >N submits rápidos en login/refresh"
      - "mostrar 429 AUTH_RATE_LIMIT y bloquear UI temporalmente"

security_and_privacy:
  - "No loguear tokens ni contenidos sensibles."
  - "Si REFRESH_TRANSPORT='body', definir storage seguro (ideal: sessionStorage) y limpieza en logout."
  - "Todos los errores se muestran mapeados a mensajes genéricos (no revelar existencia de email)."

deliverables:
  - "Todos los archivos de file_structure con funciones vacías pero firmadas según este contrato."
  - "IDs de DOM exactos según dom_contracts."
  - "Listeners conectados según events_and_listeners."
  - "Flujos API→Service→Utils→Render exactamente como se detalla."
  - "Textos de error según error_messages_map."
  - "Config global inyectable (API_BASE, REFRESH_TRANSPORT, intervalos)."

done_definition:
  - "La SPA navega entre vistas y ejecuta todos los flujos sin errores de referencia."
  - "Cada botón y form dispara su listener y llama a la función que corresponde."
  - "Todos los contratos de datos (inputs/outputs) están respetados."
  - "Criterios de aceptación frontend cumplidos y manuales."
