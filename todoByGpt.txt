ChatGPT said:

1 Definir archivo .env con credenciales y rutas (Postgres, Redis, claves, modos).

2 Diseñar esquema de Postgres (users, data_public, data_private, data_protected, refresh_tokens, sesiones).

3 Escribir migraciones SQL iniciales y script de bootstrap de base de datos.

4 Crear índices y constraints (unicidad mail/username, FK y ON DELETE apropiados).

5 Implementar conexión directa a Postgres (pooling) y helpers de consultas parametrizadas.

6 Configurar Redis (db, TTLs, namespaces para sesiones y claves AES stateful).

7 Implementar rotación de claves AES stateful (cada 15 min) y limpieza de expirados.

8 Generar o cargar claves de curva elíptica (cifrado) y RSA (firma) al iniciar.

9 Implementar KMS interno: crearKeyUser() y decifrarKey(keyEncripted).

10 Implementar hash de contraseñas (Argon2 o bcrypt) y verificación.

11 Implementar módulo JWT (claims, expiraciones, firma, verificación, clock skew).

12 Implementar cifradoStateLess(body, AESdelCliente) y descifradoStateLess(body).

13 Implementar cifradoStateFull(body, idSesion) y descifradoStateFull(body).

14 Implementar handshake(): recibir AES cliente, crear sesión, devolver idSesion y JWT cifrados.

15 Implementar endpoint /register (ejecuta handshake, crea usuario, devuelve JWT cifrado).

16 Implementar endpoint /login (ejecuta handshake, valida credenciales, devuelve JWT cifrado).

17 Implementar endpoint /refresh (valida refresh token, emite access nuevo, cifra respuesta).

18 Implementar endpoint /logout (revoca refresh y cierra sesión stateful si aplica).

19 Diseñar DAO/servicios para users y tokens con queries SQL explícitas.

20 Implementar validaciones de entrada (schemas, sanitización, límites de tamaño).

21 Configurar CORS, headers de seguridad y deshabilitar verbos no usados.

22 Implementar rate limiting por IP/usuario y detección básica de brute force.

23 Implementar anti-replay en stateless (nonce/timestamp y ventana de tolerancia).

24 Registrar auditoría: log de accesos, intentos fallidos, refresh y logout.

25 Implementar rotación/blacklist de refresh tokens (jti) y revocación por usuario.

26 Crear seeds de datos para desarrollo (usuarios de prueba, claves, sesiones).

27 Escribir pruebas unitarias de cifrado/descifrado, JWT y KMS.

28 Escribir pruebas de integración de los flujos register/login/refresh/logout.

29 Preparar perfiles de entorno (dev/stage/prod) y configuración por variables.

30 Implementar manejo de errores y respuestas estandarizadas (códigos y mensajes).

31 Documentar contratos de API (OpenAPI/Swagger) y ejemplos de payload cifrado.

32 Implementar selección por endpoint del modo (stateful/stateless) vía middleware.

33 Asegurar sincronización de tiempo (NTP) para validaciones de tokens.

34 Implementar limpieza programada de sesiones y refresh expirados (cron/worker).

35 Contenerizar servicio (Dockerfile) y definir docker-compose para Postgres/Redis.

36 Configurar CI para lint, tests, migraciones y build de imagen.

37 Medir rendimiento (benchmarks) y ajustar TTLs, tamaños de payload y pool sizes.

38 Implementar límites de tamaño de body y compresión de respuestas cifradas.

39 Añadir end-to-end tests cifrados contra una base Postgres/Redis real.

40 Escribir guía operativa: rotación de claves, backup/restore y procedimientos de incidente.