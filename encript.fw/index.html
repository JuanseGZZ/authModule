<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Handshake RSA→AES - verbose logs</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding:16px }
    pre { white-space: pre-wrap; background:#0b1220; color:#e6eef8; padding:12px; border-radius:8px; max-height:80vh; overflow:auto }
    button { padding:8px 12px; border-radius:8px; margin-bottom:8px }
    .k { color:#8be9a8 }
    .e { color:#ff9f89 }
  </style>
</head>
<body>
<h1>Handshake RSA→AES (verbose)</h1>
<button id="doAll">Run handshake + echo</button>
<pre id="log"></pre>

<script>
const logEl = document.getElementById('log');
function log(...args){ logEl.textContent += args.join(' ') + '\n'; console.log(...args); }

const BASE_URL = 'http://localhost:8000';
const enc = new TextEncoder();
const dec = new TextDecoder();

function toB64(u8){ return btoa(String.fromCharCode(...u8)); }
function fromB64(b){ return Uint8Array.from(atob(b), c=>c.charCodeAt(0)); }
function pemToDer(pem){ const b64 = pem.replace(/-----(BEGIN|END) [^-]+-----/g,'').replace(/\s+/g,''); return fromB64(b64); }

async function run(){
  try{
    log("=== FRONT: start ===");

    // 1) fetch server public key (SPKI PEM, b64)
    log("[FRONT] Fetching server public key...");
    const kresp = await fetch(`${BASE_URL}/getKeyPublic`).then(r=>r.json());
    log("[FRONT] Received backend_public_spki_pem_b64 len:", (kresp.backend_public_spki_pem_b64||"").length);
    const backendSpkiPem = atob(kresp.backend_public_spki_pem_b64);
    log("[FRONT] backend SPKI PEM (first 300 chars):\n", backendSpkiPem.slice(0,300));
    const backendDer = pemToDer(backendSpkiPem);
    const backendPubKey = await crypto.subtle.importKey('spki', backendDer.buffer, {name:'RSA-OAEP', hash:'SHA-256'}, false, ['encrypt']);
    log("[FRONT] Imported backend public key into WebCrypto.");

    // 2) create AES key bytes and nonce
    const aesRaw = crypto.getRandomValues(new Uint8Array(32)); // AES-256
    const nonce = crypto.getRandomValues(new Uint8Array(16));
    log("[FRONT] Generated AES raw (hex):", Array.from(aesRaw).map(x=>x.toString(16).padStart(2,'0')).join('').slice(0,120) + " ...");
    log("[FRONT] AES raw (b64):", toB64(aesRaw));
    log("[FRONT] Nonce (b64):", toB64(nonce));

    // 3) build small JSON and RSA-encrypt it with server public
    const rsaPayload = { aes_key_b64: toB64(aesRaw), nonce_b64: toB64(nonce) };
    const rsaPayloadBytes = enc.encode(JSON.stringify(rsaPayload));
    log("[FRONT] RSA payload JSON:", JSON.stringify(rsaPayload));
    log("[FRONT] RSA payload bytes len:", rsaPayloadBytes.byteLength);

    const rsaCt = new Uint8Array(await crypto.subtle.encrypt({name:'RSA-OAEP'}, backendPubKey, rsaPayloadBytes));
    log("[FRONT] RSA ciphertext (front→back) b64 len:", toB64(rsaCt).length);
    log("[FRONT] RSA ciphertext (front→back) b64 (first 240 chars):", toB64(rsaCt).slice(0,240) + " ...");

    // 4) send handshake (only rsa_ct_b64)
    log("[FRONT] POST /handshake/start with rsa_ct_b64...");
    const hsRes = await fetch(`${BASE_URL}/handshake/start`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ rsa_ct_b64: toB64(rsaCt) })
    });
    const hsJson = await hsRes.json();
    if (!hsRes.ok) {
      log("[FRONT] Handshake failed:", hsJson);
      throw new Error("handshake failed: " + (hsJson.detail || JSON.stringify(hsJson)));
    }

    log("[FRONT] Handshake response debug_server_plain_b64 (b64 of RSA-decrypted blob on server):", hsJson.debug_server_plain_b64);
    log("[FRONT] Handshake response debug_aes_key_b64 (server saw AES key b64):", hsJson.debug_aes_key_b64);
    log("[FRONT] Server sent (iv_b64):", hsJson.iv_b64);
    log("[FRONT] Server sent (ciphertext_b64 len):", hsJson.ciphertext_b64.length);
    log("[FRONT] Server ciphertext (first 240 b64 chars):", hsJson.ciphertext_b64.slice(0,240) + " ...");

    // 5) decode server's AES response: base64 -> bytes -> AES-GCM decrypt with AES we generated
    log("[FRONT] Decoding server handshake response (base64 -> bytes)...");
    const iv_hs = fromB64(hsJson.iv_b64);
    const ct_hs = fromB64(hsJson.ciphertext_b64);
    log("[FRONT] iv (hex):", Array.from(iv_hs).map(x=>x.toString(16).padStart(2,'0')).join(''));
    log("[FRONT] ct (hex first 160):", Array.from(ct_hs).map(x=>x.toString(16).padStart(2,'0')).join('').slice(0,160) + " ...");

    const aesKey = await crypto.subtle.importKey('raw', aesRaw, {name:'AES-GCM'}, false, ['encrypt','decrypt']);
    log("[FRONT] Imported AES key into WebCrypto.");

    const hsPlainBytes = new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv: iv_hs}, aesKey, ct_hs));
    log("[FRONT] Decrypted handshake plaintext (utf8):", dec.decode(hsPlainBytes));
    log("[FRONT] Decrypted handshake plaintext (b64):", toB64(hsPlainBytes));
    const hsObj = JSON.parse(dec.decode(hsPlainBytes));
    log("[FRONT] session_id from server:", hsObj.session_id);

    // 6) Now test AES channel: encrypt a message and send it
    const msg = "hola back, soy el front";
    const iv1 = crypto.getRandomValues(new Uint8Array(12));
    const ct1 = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv: iv1}, aesKey, enc.encode(msg)));
    log("[FRONT] Plain message:", msg);
    log("[FRONT] iv (b64):", toB64(iv1));
    log("[FRONT] ciphertext (b64):", toB64(ct1));
    log("[FRONT] ciphertext (hex first 200):", Array.from(ct1).map(x=>x.toString(16).padStart(2,'0')).join('').slice(0,200) + " ...");

    const echoRes = await fetch(`${BASE_URL}/secure/echo`, {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({
        session_id: hsObj.session_id,
        iv_b64: toB64(iv1),
        ciphertext_b64: toB64(ct1)
      })
    });
    const echoJson = await echoRes.json();
    if (!echoRes.ok) {
      log("[FRONT] Echo failed:", echoJson);
      throw new Error("echo failed: " + (echoJson.detail || JSON.stringify(echoJson)));
    }

    // 7) show server debug and decrypt reply with AES
    log("[FRONT] Server debug received plain (b64):", echoJson.debug_server_received_plain_b64);
    log("[FRONT] Server debug reply plain (b64):", echoJson.debug_server_reply_plain_b64);
    log("[FRONT] Server reply IV (b64):", echoJson.iv_b64);
    log("[FRONT] Server reply CT (b64 len):", echoJson.ciphertext_b64.length);
    log("[FRONT] Server reply CT (b64 first 240):", echoJson.ciphertext_b64.slice(0,240) + " ...");

    const iv2 = fromB64(echoJson.iv_b64);
    const ct2 = fromB64(echoJson.ciphertext_b64);

    log("[FRONT] Reply iv (hex):", Array.from(iv2).map(x=>x.toString(16).padStart(2,'0')).join(''));
    log("[FRONT] Reply ct (hex first 200):", Array.from(ct2).map(x=>x.toString(16).padStart(2,'0')).join('').slice(0,200) + " ...");

    const replyPlainBytes = new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv: iv2}, aesKey, ct2));
    log("[FRONT] Decrypted reply plain (utf8):", dec.decode(replyPlainBytes));
    log("[FRONT] Decrypted reply plain (b64):", toB64(replyPlainBytes));
    log("=== FRONT: done ===");

  } catch(err) {
    log("[FRONT] ERROR:", err && err.message ? err.message : err);
    console.error(err);
  }
}

document.getElementById('doAll').onclick = run;
</script>
</body>
</html>
